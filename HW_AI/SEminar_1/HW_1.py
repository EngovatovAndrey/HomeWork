# Обязательное ДЗ - Реализовать алгоритм пирамидальной сортировки (сортировка кучей).
from random import randint
test_arr = [randint(1,1000) for _ in range(30)]
print(test_arr)

def heapify(arr, n, i):
    largest = i # Initialize largest as root
    l = 2 * i + 1   # left = 2*i + 1
    r = 2 * i + 2   # right = 2*i + 2

  # Проверяем существует ли левый дочерний элемент больший, чем корень

    if l < n and arr[i] < arr[l]:
        largest = l

  # Проверяем существует ли правый дочерний элемент больший, чем корень

    if r < n and arr[largest] < arr[r]:
        largest = r

    # Заменяем корень, если нужно
    if largest != i:
        arr[i],arr[largest] = arr[largest],arr[i] # свап

        # Применяем heapify к корню.
        heapify(arr, n, largest)

# Основная функция для сортировки массива заданного размера
def heapSort(arr):
    n = len(arr)

    # Построение max-heap.
    for i in range(n, -1, -1):
        heapify(arr, n, i)

    # Один за другим извлекаем элементы
    for i in range(n-1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i] # свап 
        heapify(arr, i, 0)

# Управляющий код для тестирования
arr = [ 12, 11, 13, 5, 6, 7]
heapSort(test_arr)
n = len(arr)
print ("Sorted array is", test_arr)



# задание 1 доп необязательное 
# Доработать алгоритм сортировки подсчетом для и отрицательных чисел.
# задание 2 доп необязательное
# Аналитически обосновать в каких случаях эффективнее применять быструю сортировку, а когда сортировку подсчетом. Произвести ряд экспериментов с различной длиной массивов и различным диапазоном значений. Оценить и интерпретировать результаты экспериментов, соотнести с теоретическими выкладками.
# задание 3 доп необязательное VERY HARD
# Надо сделать имитацию БД по хранению чисел.
# шаг 1 - генерируем список со случайной длиной , со случайным минимальных значением и случайным максимальным. Можно вывести на экран.
# шаг 2 - ваша программа выбирает наилучший вариант сортировки исходя из параметров входного массива - как минимум, из двух вариантов - из сортировки подсчетом и из быстрой сортировки.
# шаг 3 - производится сортировка и создается некая коллекция данных, которая хранит в себе первоначальное расположение элементов. Засекаем время выполнения и выводим на экран.
# шаг 4 - вы вводите число с клавиатуры, далее выполняется бинарный поиск всех таких значений. Засекаем время выполнения и выводим на экран.
# шаг 5 - вам выводятся индексы первоначального списка с шага 1, где находились такие числа.
# шаги 4-5 можно сделать внутри цикла while True.
# Мораль этого задания - можно помучиться один раз, выполнить сортировку, зато потом будет очень быстрый поиск элементов.
# Пример работы программы - на входе массив [0 ,1 ,5 ,8 99, 100,1]
# Вы ввели -> 1
# вам выдается 1,6 то есть значение 1 в первоначальном списке находилось на позициях 1 и 6